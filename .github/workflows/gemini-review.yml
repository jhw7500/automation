name: 'ðŸ”Ž Gemini Review'

on:
  workflow_call:
    inputs:
      pr_number:
        type: 'string'
        description: 'Pull request number (optional; defaults to event PR number)'
        required: false
      issue_title:
        type: 'string'
        description: 'Issue/PR title (optional; defaults to event title)'
        required: false
      issue_body:
        type: 'string'
        description: 'Issue/PR body (optional; defaults to event body)'
        required: false
      additional_context:
        type: 'string'
        description: 'Any additional context from the request'
        required: false
      patch:
        type: 'string'
        description: 'Whether to generate a patch (true/false)'
        required: false
        default: 'false'
      incremental:
        type: 'string'
        description: 'Whether to perform incremental review (true/false)'
        required: false
        default: 'false'
      last_success_sha:
        type: 'string'
        description: 'Last successful review commit SHA'
        required: false

concurrency:
  group: '${{ github.workflow }}-review-${{ github.event_name }}-${{ inputs.pr_number || github.event.pull_request.number || github.event.issue.number }}'
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash'

jobs:
  review:
    runs-on: 'ubuntu-latest'
    timeout-minutes: 15
    permissions:
      contents: 'read'
      id-token: 'write'
      issues: 'write'
      pull-requests: 'write'
    steps:
      - name: 'Checkout repository (sparse)'
        if: vars.GEMINI_SPARSE_CHECKOUT == 'true' && vars.GEMINI_SPARSE_CHECKOUT_PATTERNS != ''
        uses: 'actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8' # ratchet:actions/checkout@v5
        with:
          fetch-depth: 0
          lfs: false
          submodules: false
          sparse-checkout-cone-mode: false
          sparse-checkout: |-
            ${{ vars.GEMINI_SPARSE_CHECKOUT_PATTERNS }}

      - name: 'Checkout repository'
        if: vars.GEMINI_SPARSE_CHECKOUT != 'true'
        uses: 'actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8' # ratchet:actions/checkout@v5
        with:
          fetch-depth: 0
          lfs: false
          submodules: false

      - name: 'Determine diff range'
        id: 'diff_range'
        run: |-
          BASE_SHA=""
          HEAD_SHA="${{ github.event.pull_request.head.sha || github.sha }}"
          
          if [[ "${{ inputs.incremental }}" == "true" && -n "${{ inputs.last_success_sha }}" ]]; then
            echo "Incremental review requested."
            if git merge-base --is-ancestor "${{ inputs.last_success_sha }}" "$HEAD_SHA"; then
              BASE_SHA="${{ inputs.last_success_sha }}"
              echo "Using last_success_sha as base: $BASE_SHA"
            else
              echo "last_success_sha is not an ancestor of HEAD. Falling back to PR base."
              BASE_SHA="${{ github.event.pull_request.base.sha || 'HEAD~1' }}"
            fi
          else
            BASE_SHA="${{ github.event.pull_request.base.sha || 'HEAD~1' }}"
            echo "Using default base: $BASE_SHA"
          fi
          
          echo "base_sha=$BASE_SHA" >> $GITHUB_OUTPUT
          echo "head_sha=$HEAD_SHA" >> $GITHUB_OUTPUT

      - name: 'Setup safe shell wrappers'
        run: &setup_safe_shell_wrappers |-
          set -euo pipefail

          # Create safe wrappers for the limited shell tools enabled in gemini-cli settings.
          # These wrappers refuse large/binary payloads to prevent prompt/context explosions.
          mkdir -p .gemini/safe-bin

          cat > .gemini/safe-bin/_validate_file.sh <<'SH'
          #!/usr/bin/env sh
          set -eu

          max_bytes="${GEMINI_MAX_READ_BYTES:-200000}"

          is_blocked_ext() {
            case "$1" in
              *.bin|*.ko|*.deb|*.tar|*.tar.gz|*.tgz|*.zip|*.gz|*.xz|*.7z|*.exe|*.so|*.a|*.o)
                return 0
                ;;
            esac
            return 1
          }

          is_text_file() {
            mime=$(file -b --mime-type "$1" 2>/dev/null || true)
            case "$mime" in
              text/*|application/json|application/xml)
                return 0
                ;;
            esac
            return 1
          }

          validate_file() {
            f="$1"

            if [ "$f" = "-" ]; then
              echo "ERROR: refusing to read from stdin" >&2
              exit 2
            fi

            if is_blocked_ext "$f"; then
              echo "ERROR: refusing to read blocked file type: $f" >&2
              exit 2
            fi

            if [ ! -f "$f" ]; then
              echo "ERROR: file not found or not a regular file: $f" >&2
              exit 2
            fi

            size=$(wc -c < "$f" | tr -d ' ')
            if [ "$size" -gt "$max_bytes" ]; then
              echo "ERROR: refusing to read large file ($size bytes): $f" >&2
              exit 2
            fi

            if ! is_text_file "$f"; then
              echo "ERROR: refusing to read non-text file: $f" >&2
              exit 2
            fi
          }

          for arg in "$@"; do
            if [ -f "$arg" ]; then
              validate_file "$arg"
            fi
          done
          SH

          chmod +x .gemini/safe-bin/_validate_file.sh

          cat > .gemini/safe-bin/cat <<'SH'
          #!/usr/bin/env sh
          set -eu
          "${0%/*}/_validate_file.sh" "$@"
          exec /bin/cat "$@"
          SH

          cat > .gemini/safe-bin/head <<'SH'
          #!/usr/bin/env sh
          set -eu
          "${0%/*}/_validate_file.sh" "$@"
          exec /usr/bin/head "$@"
          SH

          cat > .gemini/safe-bin/tail <<'SH'
          #!/usr/bin/env sh
          set -eu
          "${0%/*}/_validate_file.sh" "$@"
          exec /usr/bin/tail "$@"
          SH

          cat > .gemini/safe-bin/grep <<'SH'
          #!/usr/bin/env sh
          set -eu
          "${0%/*}/_validate_file.sh" "$@"
          exec /usr/bin/grep "$@"
          SH

          chmod +x .gemini/safe-bin/cat .gemini/safe-bin/head .gemini/safe-bin/tail .gemini/safe-bin/grep

      - name: 'Setup authentication'
        id: 'auth'
        uses: 'jhw7500/automation/.github/actions/setup-gemini-auth@v1.1'
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'
          fallback-token: '${{ secrets.GITHUB_TOKEN || github.token }}'

      - name: 'Generate diff'
        id: 'generate_diff'
        run: |-
          DIFF_FILE="dynamic_diff.txt"
          git diff "${{ steps.diff_range.outputs.base_sha }}"..."${{ steps.diff_range.outputs.head_sha }}" > "$DIFF_FILE"
          echo "diff_file=$DIFF_FILE" >> $GITHUB_OUTPUT

      - name: 'Generate patch (if requested)'
        id: 'generate_patch'
        if: inputs.patch == 'true'
        run: |-
          PATCH_FILE="review.patch"
          git format-patch "${{ steps.diff_range.outputs.base_sha }}"..."${{ steps.diff_range.outputs.head_sha }}" --stdout > "$PATCH_FILE"
          echo "patch_file=$PATCH_FILE" >> $GITHUB_OUTPUT

      - name: 'Run Gemini pull request review (primary, attempt 1)'
        uses: 'google-github-actions/run-gemini-cli@v0' # ratchet:exclude
        id: 'gemini_pr_review_1'
        timeout-minutes: 4
        continue-on-error: true
        env: &gemini_review_env
          PATH: '${{ github.workspace }}/.gemini/safe-bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
          GEMINI_MAX_READ_BYTES: '${{ vars.GEMINI_MAX_READ_BYTES || 200000 }}'
          GITHUB_TOKEN: '${{ steps.auth.outputs.token }}'
          ISSUE_TITLE: '${{ inputs.issue_title || github.event.pull_request.title || github.event.issue.title }}'
          ISSUE_BODY: '${{ inputs.issue_body || github.event.pull_request.body || github.event.issue.body }}'
          PULL_REQUEST_NUMBER: '${{ inputs.pr_number || github.event.pull_request.number || github.event.issue.number }}'
          REPOSITORY: '${{ github.repository }}'
          ADDITIONAL_CONTEXT: '${{ inputs.additional_context }}'
          DIFF_FILE: '${{ steps.generate_diff.outputs.diff_file }}'
          PATCH_FILE: '${{ steps.generate_patch.outputs.patch_file }}'
        with:
          gcp_location: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          gcp_project_id: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          gcp_service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          gcp_workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          gemini_cli_version: '${{ vars.GEMINI_CLI_VERSION }}'
          gemini_debug: "${{ vars.GEMINI_DEBUG == 'true' || vars.ACTIONS_STEP_DEBUG == 'true' }}"
          gemini_model: '${{ vars.GEMINI_MODEL }}'
          google_api_key: '${{ secrets.GOOGLE_API_KEY }}'
          use_gemini_code_assist: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          use_vertex_ai: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          upload_artifacts: '${{ vars.UPLOAD_ARTIFACTS }}'
          workflow_name: 'gemini-review'
          settings: &gemini_review_settings |-
            {
              "model": {
                "maxSessionTurns": 25
              },
              "telemetry": {
                "enabled": true,
                "target": "local",
                "outfile": ".gemini/telemetry.log"
              },
              "mcpServers": {
                "github": {
                  "command": "docker",
                  "args": [
                    "run",
                    "-i",
                    "--rm",
                    "-e",
                    "GITHUB_PERSONAL_ACCESS_TOKEN",
                    "ghcr.io/github/github-mcp-server:v0.18.0@sha256:6aa543f565bc98d96106fdd80a0abdc0c7147c8ca7f4663a814ceecef1ccc6d3"
                  ],
                  "includeTools": [
                    "add_comment_to_pending_review",
                    "create_pending_pull_request_review",
                    "pull_request_read",
                    "submit_pending_pull_request_review"
                  ],
                  "env": {
                    "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_TOKEN}"
                  }
                }
              },
              "tools": {
                "core": [
                  "run_shell_command(cat)",
                  "run_shell_command(echo)",
                  "run_shell_command(grep)",
                  "run_shell_command(head)",
                  "run_shell_command(tail)"
                ]
              }
            }
          prompt: &gemini_review_prompt |-
            Start your response with:
            REPO: ${{ github.repository }}
            PR NUMBER: ${{ inputs.pr_number || github.event.pull_request.number || github.event.issue.number }}
            Reviewer: Gemini Dispatch (Broad Review)

            You are performing a deep, professional review based on the provided diff.
            The user has requested a review with the following parameters:
            - Incremental: ${{ inputs.incremental }}
            - Generate Patch: ${{ inputs.patch }}

            **Diff for review:**
            ```diff
            ${{ env.DIFF_FILE && fromJSON(toJSON(env.DIFF_FILE)) }}
            ```

            **Instructions:**
            1.  **Analyze the diff**: Focus on missing improvements, latent risks, and hardening opportunities in areas touched by the changes. Do NOT repeat change-specific findings that a simple diff review would cover.
            2.  **Provide a concise review**: Structure your response with clear headings.
                - Broader risks or gaps not addressed.
                - Improvements that should be scheduled soon.
                - Architectural or operational concerns.
            3.  **Generate a patch (if requested)**: If `Generate Patch` is `true`, create a patch file named `review.patch` that includes your suggested improvements. The patch should be in the `git format-patch` style.
            4.  **Exclude CI/CD commentary.**

      - name: 'Backoff before retry'
        if: steps.gemini_pr_review_1.outcome != 'success'
        run: sleep 20

      - name: 'Reset Gemini workspace before retry'
        if: steps.gemini_pr_review_1.outcome != 'success'
        run: |-
          rm -rf .gemini

      - name: 'Setup safe shell wrappers (retry)'
        if: steps.gemini_pr_review_1.outcome != 'success'
        run: *setup_safe_shell_wrappers

      - name: 'Run Gemini pull request review (primary, attempt 2)'
        if: steps.gemini_pr_review_1.outcome != 'success'
        uses: 'google-github-actions/run-gemini-cli@v0' # ratchet:exclude
        id: 'gemini_pr_review_2'
        timeout-minutes: 4
        continue-on-error: true
        env: *gemini_review_env
        with:
          gcp_location: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          gcp_project_id: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          gcp_service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          gcp_workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          gemini_cli_version: '${{ vars.GEMINI_CLI_VERSION }}'
          gemini_debug: "${{ vars.GEMINI_DEBUG == 'true' || vars.ACTIONS_STEP_DEBUG == 'true' }}"
          gemini_model: '${{ vars.GEMINI_MODEL }}'
          google_api_key: '${{ secrets.GOOGLE_API_KEY }}'
          use_gemini_code_assist: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          use_vertex_ai: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          upload_artifacts: '${{ vars.UPLOAD_ARTIFACTS }}'
          workflow_name: 'gemini-review'
          settings: *gemini_review_settings
          prompt: *gemini_review_prompt

      - name: 'Backoff before fallback'
        if: steps.gemini_pr_review_1.outcome != 'success' && steps.gemini_pr_review_2.outcome != 'success'
        run: sleep 20

      - name: 'Reset Gemini workspace before fallback'
        if: steps.gemini_pr_review_1.outcome != 'success' && steps.gemini_pr_review_2.outcome != 'success'
        run: |-
          rm -rf .gemini

      - name: 'Setup safe shell wrappers (fallback)'
        if: steps.gemini_pr_review_1.outcome != 'success' && steps.gemini_pr_review_2.outcome != 'success'
        run: *setup_safe_shell_wrappers

      - name: 'Run Gemini pull request review (fallback model)'
        if: steps.gemini_pr_review_1.outcome != 'success' && steps.gemini_pr_review_2.outcome != 'success'
        uses: 'google-github-actions/run-gemini-cli@v0' # ratchet:exclude
        id: 'gemini_pr_review_fallback'
        timeout-minutes: 4
        continue-on-error: true
        env: *gemini_review_env
        with:
          gcp_location: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          gcp_project_id: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          gcp_service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          gcp_workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          gemini_cli_version: '${{ vars.GEMINI_CLI_VERSION }}'
          gemini_debug: "${{ vars.GEMINI_DEBUG == 'true' || vars.ACTIONS_STEP_DEBUG == 'true' }}"
          gemini_model: "${{ vars.GEMINI_FALLBACK_MODEL || 'gemini-3-flash-preview' }}"
          google_api_key: '${{ secrets.GOOGLE_API_KEY }}'
          use_gemini_code_assist: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          use_vertex_ai: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          upload_artifacts: '${{ vars.UPLOAD_ARTIFACTS }}'
          workflow_name: 'gemini-review'
          settings: *gemini_review_settings
          prompt: *gemini_review_prompt

      - name: 'Fail job if all review attempts failed'
        if: always()
        run: |-
          if [ "${{ steps.gemini_pr_review_1.outcome }}" = 'success' ]; then exit 0; fi
          if [ "${{ steps.gemini_pr_review_2.outcome }}" = 'success' ]; then exit 0; fi
          if [ "${{ steps.gemini_pr_review_fallback.outcome }}" = 'success' ]; then exit 0; fi
          exit 1

      - name: 'Notify and Persist on Finish'
        if: always()
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # ratchet:actions/github-script@v7
        env:
          ISSUE_NUMBER: '${{ inputs.pr_number || github.event.pull_request.number || github.event.issue.number }}'
          RUN_URL: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
          MODEL_PRIMARY: '${{ vars.GEMINI_MODEL }}'
          MODEL_FALLBACK: "${{ vars.GEMINI_FALLBACK_MODEL || 'gemini-3-flash-preview' }}"
          OUTCOME_1: '${{ steps.gemini_pr_review_1.outcome }}'
          RESP_1: '${{ steps.gemini_pr_review_1.outputs.gemini_response }}'
          ERR_1: '${{ steps.gemini_pr_review_1.outputs.gemini_errors }}'
          OUTCOME_2: '${{ steps.gemini_pr_review_2.outcome }}'
          RESP_2: '${{ steps.gemini_pr_review_2.outputs.gemini_response }}'
          ERR_2: '${{ steps.gemini_pr_review_2.outputs.gemini_errors }}'
          OUTCOME_FB: '${{ steps.gemini_pr_review_fallback.outcome }}'
          RESP_FB: '${{ steps.gemini_pr_review_fallback.outputs.gemini_response }}'
          ERR_FB: '${{ steps.gemini_pr_review_fallback.outputs.gemini_errors }}'
          HEAD_SHA: '${{ steps.diff_range.outputs.head_sha }}'
        with:
          github-token: '${{ github.token }}'
          script: |
            const marker = '<!-- automation:gemini-review -->';
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            const runUrl = process.env.RUN_URL;

            const maxLen = 60000;
            const trim = (s) => {
              const t = (s || '').trim();
              if (t.length <= maxLen) return t;
              return t.slice(0, maxLen) + `\n\n...(truncated, ${t.length - maxLen} chars omitted)`;
            };

            const pick = () => {
              if ((process.env.OUTCOME_1 || '').toLowerCase() === 'success') {
                return { ok: true, model: process.env.MODEL_PRIMARY || '', response: process.env.RESP_1 || '', error: '' };
              }
              if ((process.env.OUTCOME_2 || '').toLowerCase() === 'success') {
                return { ok: true, model: process.env.MODEL_PRIMARY || '', response: process.env.RESP_2 || '', error: '' };
              }
              if ((process.env.OUTCOME_FB || '').toLowerCase() === 'success') {
                return { ok: true, model: process.env.MODEL_FALLBACK || '', response: process.env.RESP_FB || '', error: '' };
              }

              // Prefer the fallback error if present; otherwise take the first non-empty.
              const err = process.env.ERR_FB || process.env.ERR_2 || process.env.ERR_1 || '';
              return { ok: false, model: process.env.MODEL_PRIMARY || '', response: '', error: err };
            };

            const summarizeError = (raw) => {
              const t = (raw || '').trim();
              if (!t) return '';
              const lines = t.split('\n').slice(0, 30).join('\n');
              return trim(lines);
            };

            const result = pick();
            const stickyData = {
              status: result.ok ? 'success' : 'failure',
              model: result.model,
              run_url: runUrl,
              ...(result.ok && { last_success_sha: process.env.HEAD_SHA }),
            };
            const header = `## Gemini Review (latest)\n<!-- automation:gemini-review ${JSON.stringify(stickyData)} -->`;

            const meta = [
              `- Status: ${result.ok ? 'success' : 'failure'}`,
              result.model ? `- Model: ${result.model}` : null,
              `- Run: ${runUrl}`,
            ].filter(Boolean).join('\n');

            const content = result.ok
              ? `\n\n${trim(result.response) || `(No response captured. Check run logs: ${runUrl})`}`
              : `\n\n### Error\n\n\`\`\`\n${summarizeError(result.error) || '(no error text captured)'}\n\`\`\`\n\n(See run logs: ${runUrl})`;

            const body = `${header}\n\n${meta}${content}`;

            const { owner, repo } = context.repo;
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: issueNumber,
              per_page: 100,
            });

            const existing = comments.find((c) => (c.body || '').includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body });
            }
