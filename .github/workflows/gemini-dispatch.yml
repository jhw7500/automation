name: 'ðŸ”€ Gemini Dispatch'

on:
  workflow_call:
    inputs:
      force_run:
        description: 'Run even if disabled in workflow-config.yml'
        type: boolean
        required: false
        default: false

defaults:
  run:
    shell: 'bash'

jobs:
  check-enabled:
    name: Check if enabled
    runs-on: ubuntu-latest
    outputs:
      enabled: ${{ steps.check.outputs.enabled }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          sparse-checkout: .github

      - name: Check workflow config
        id: check
        uses: jhw7500/automation/.github/actions/check-workflow-enabled@v1.1
        with:
          workflow-name: gemini-dispatch
          force-run: ${{ inputs.force_run && 'true' || 'false' }}

  debugger:
    needs: check-enabled
    if: |-
      needs.check-enabled.outputs.enabled == 'true' && (vars.GEMINI_DEBUG == 'true' || vars.ACTIONS_STEP_DEBUG == 'true')
    runs-on: 'ubuntu-latest'
    permissions:
      contents: 'read'
    steps:
      - name: 'Print context for debugging'
        env:
          DEBUG_event_name: '${{ github.event_name }}'
          DEBUG_event__action: '${{ github.event.action }}'
          DEBUG_event__comment__author_association: '${{ github.event.comment.author_association }}'
          DEBUG_event__issue__author_association: '${{ github.event.issue.author_association }}'
          DEBUG_event__pull_request__author_association: '${{ github.event.pull_request.author_association }}'
          DEBUG_event__review__author_association: '${{ github.event.review.author_association }}'
          DEBUG_event: '${{ toJSON(github.event) }}'
        run: |-
          env | grep '^DEBUG_'

  dispatch:
    needs: check-enabled
    if: needs.check-enabled.outputs.enabled == 'true'
    runs-on: 'ubuntu-latest'
    permissions:
      contents: 'read'
      issues: 'write'
      pull-requests: 'write'
    outputs:
      command: '${{ steps.extract_command.outputs.command }}'
      request: '${{ steps.extract_command.outputs.request }}'
      additional_context: '${{ steps.extract_command.outputs.additional_context }}'
      issue_number: '${{ github.event.pull_request.number || github.event.issue.number }}'
      review_enabled: '${{ steps.check_config.outputs.review_enabled }}'
      triage_enabled: '${{ steps.check_config.outputs.triage_enabled }}'
      invoke_enabled: '${{ steps.check_config.outputs.invoke_enabled }}'
      auto_pr_review_enabled: '${{ steps.check_config.outputs.auto_pr_review_enabled }}'
    steps:
      - name: 'Checkout for config'
        uses: 'actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8' # ratchet:actions/checkout@v5
        with:
          sparse-checkout: .github

      - name: 'Check workflow config'
        id: 'check_config'
        run: |-
          CONFIG_FILE=".github/workflow-config.yml"

          get_enabled() {
            local workflow="$1"
            if [[ -f "$CONFIG_FILE" ]]; then
              grep -A1 "^  ${workflow}:" "$CONFIG_FILE" | grep "enabled:" | sed 's/.*enabled: *//' | tr -d ' ' || echo "true"
            else
              echo "true"
            fi
          }

          echo "review_enabled=$(get_enabled 'gemini-review')" >> $GITHUB_OUTPUT
          echo "triage_enabled=$(get_enabled 'gemini-triage')" >> $GITHUB_OUTPUT
          echo "invoke_enabled=$(get_enabled 'gemini-invoke')" >> $GITHUB_OUTPUT

          # Global auto-review toggle. Defaults to true if missing.
          auto_pr_review_enabled="true"
          if [[ -f "$CONFIG_FILE" ]]; then
            auto_pr_review_enabled="$(ruby -ryaml -e 'cfg = (YAML.load_file(ARGV[0]) rescue {}) || {}; v = cfg.dig("review", "auto"); v = true if v.nil?; puts(v ? "true" : "false")' "$CONFIG_FILE" 2>/dev/null || echo true)"
          fi
          echo "auto_pr_review_enabled=${auto_pr_review_enabled}" >> $GITHUB_OUTPUT

      - name: 'Mint identity token'
        id: 'mint_identity_token'
        if: |-
          ${{ vars.APP_ID }}
        uses: 'actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b' # ratchet:actions/create-github-app-token@v2
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'
          permission-contents: 'read'
          permission-issues: 'write'
          permission-pull-requests: 'write'

      - name: 'Extract command'
        id: 'extract_command'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea' # ratchet:actions/github-script@v7
        env:
          AUTO_PR_REVIEW_ENABLED: '${{ steps.check_config.outputs.auto_pr_review_enabled }}'
        with:
          script: |
            const eventType = `${context.eventName}.${context.payload.action || ''}`;
            let request =
              context.payload?.comment?.body ??
              context.payload?.review?.body ??
              context.payload?.issue?.body ??
              '';

            // Alias: allow `@gemini` to behave like `@gemini-cli`.
            // We only normalize when the mention is at the start of the request (after whitespace).
            const trimmed = request.trimStart();
            request = trimmed.replace(/^@gemini(?!-cli)\b/, '@gemini-cli');

            core.setOutput('request', request);

            if (eventType === 'pull_request.opened') {
              const autoEnabled = (process.env.AUTO_PR_REVIEW_ENABLED || 'true') === 'true';
              core.setOutput('command', autoEnabled ? 'review' : 'noop');
            } else if (['issues.opened', 'issues.reopened'].includes(eventType)) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@gemini-cli /review")) {
              core.setOutput('command', 'review');
              const additionalContext = request.replace(/^@gemini-cli \/review/, '').trim();
              core.setOutput('additional_context', additionalContext);
            } else if (request.startsWith("@gemini-cli /triage")) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@gemini-cli")) {
              const additionalContext = request.replace(/^@gemini-cli/, '').trim();
              core.setOutput('command', 'invoke');
              core.setOutput('additional_context', additionalContext);
            } else {
              core.setOutput('command', 'noop');
            }

      - name: 'Acknowledge request'
        if: steps.extract_command.outputs.command != 'noop'
        env:
          GITHUB_TOKEN: '${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN || github.token }}'
          ISSUE_NUMBER: '${{ github.event.pull_request.number || github.event.issue.number }}'
          MESSAGE: |-
            ðŸ¤– Hi @${{ github.actor }}, I've received your request, and I'm working on it now! You can track my progress [in the logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details.
          REPOSITORY: '${{ github.repository }}'
        run: |-
          gh issue comment "${ISSUE_NUMBER}" \
            --body "${MESSAGE}" \
            --repo "${REPOSITORY}"

  review:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'review' && needs.dispatch.outputs.review_enabled != 'false'
    runs-on: ubuntu-latest
    timeout-minutes: 7
    permissions:
      contents: read
      id-token: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup authentication
        id: auth
        uses: jhw7500/automation/.github/actions/setup-gemini-auth@v1.1
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'
          fallback-token: '${{ secrets.GITHUB_TOKEN || github.token }}'

      - name: Run Gemini pull request review
        uses: google-github-actions/run-gemini-cli@v0
        env:
          GITHUB_TOKEN: '${{ steps.auth.outputs.token }}'
          ISSUE_TITLE: '${{ github.event.pull_request.title || github.event.issue.title }}'
          ISSUE_BODY: '${{ github.event.pull_request.body || github.event.issue.body }}'
          PULL_REQUEST_NUMBER: '${{ github.event.pull_request.number || github.event.issue.number }}'
          REPOSITORY: '${{ github.repository }}'
          ADDITIONAL_CONTEXT: '${{ needs.dispatch.outputs.additional_context }}'
        with:
          gcp_location: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          gcp_project_id: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          gcp_service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          gcp_workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          gemini_cli_version: '${{ vars.GEMINI_CLI_VERSION }}'
          gemini_debug: "${{ vars.GEMINI_DEBUG == 'true' || vars.ACTIONS_STEP_DEBUG == 'true' }}"
          gemini_model: '${{ vars.GEMINI_MODEL }}'
          google_api_key: '${{ secrets.GOOGLE_API_KEY }}'
          use_gemini_code_assist: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          use_vertex_ai: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          upload_artifacts: '${{ vars.UPLOAD_ARTIFACTS }}'
          workflow_name: 'gemini-review'
          settings: |-
            {
              "model": { "maxSessionTurns": 25 },
              "telemetry": { "enabled": true, "target": "local", "outfile": ".gemini/telemetry.log" },
              "tools": {
                "core": [
                  "run_shell_command(cat)",
                  "run_shell_command(echo)",
                  "run_shell_command(grep)",
                  "run_shell_command(head)",
                  "run_shell_command(tail)"
                ]
              }
            }
          prompt: |-
            Start your response with:
            REPO: ${{ github.repository }}
            PR NUMBER: ${{ github.event.pull_request.number || github.event.issue.number }}
            Reviewer: Gemini Dispatch (Broad Review)

            You are performing a deep, professional review that goes BEYOND the current diff.
            Focus on missing improvements, latent risks, and hardening opportunities in areas touched by this PR.
            Do NOT repeat change-specific findings that a diff-focused review would cover.
            Exclude CI/CD commentary.

            Provide:
            1. Broader risks or gaps not addressed by this PR
            2. Improvements that should be scheduled soon (not necessarily in this PR)
            3. Any architectural or operational concerns related to the affected areas

            Keep the response concise and structured with clear headings.

  triage:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'triage' && needs.dispatch.outputs.triage_enabled != 'false'
    runs-on: ubuntu-latest
    timeout-minutes: 7
    permissions:
      contents: read
      id-token: write
      issues: write
      pull-requests: write
    steps:
      - name: Get repository labels
        id: get_labels
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          script: |-
            const labels = [];
            for await (const response of github.paginate.iterator(github.rest.issues.listLabelsForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            })) {
              labels.push(...response.data);
            }

            if (!labels || labels.length === 0) {
              core.setFailed('There are no issue labels in this repository.')
            }

            const labelNames = labels.map(label => label.name).sort();
            core.setOutput('available_labels', labelNames.join(','));
            core.info(`Found ${labelNames.length} labels: ${labelNames.join(', ')}`);
            return labelNames;

      - name: Run Gemini issue analysis
        uses: google-github-actions/run-gemini-cli@v0
        env:
          GITHUB_TOKEN: ''
          ISSUE_TITLE: '${{ github.event.issue.title }}'
          ISSUE_BODY: '${{ github.event.issue.body }}'
          AVAILABLE_LABELS: '${{ steps.get_labels.outputs.available_labels }}'
        with:
          gcp_location: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          gcp_project_id: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          gcp_service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          gcp_workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          gemini_cli_version: '${{ vars.GEMINI_CLI_VERSION }}'
          gemini_debug: "${{ vars.GEMINI_DEBUG == 'true' || vars.ACTIONS_STEP_DEBUG == 'true' }}"
          gemini_model: '${{ vars.GEMINI_MODEL }}'
          google_api_key: '${{ secrets.GOOGLE_API_KEY }}'
          use_gemini_code_assist: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          use_vertex_ai: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          upload_artifacts: '${{ vars.UPLOAD_ARTIFACTS }}'
          workflow_name: 'gemini-triage'
          settings: |-
            {
              "model": { "maxSessionTurns": 25 },
              "telemetry": { "enabled": true, "target": "local", "outfile": ".gemini/telemetry.log" },
              "tools": { "core": ["run_shell_command(echo)"] }
            }
          prompt: '/gemini-triage'

      - name: Checkout for actions
        uses: actions/checkout@v4
        with:
          sparse-checkout: .github

      - name: Setup authentication
        id: auth
        uses: jhw7500/automation/.github/actions/setup-gemini-auth@v1.1
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'
          fallback-token: '${{ secrets.GITHUB_TOKEN || github.token }}'

      - name: Apply labels
        env:
          ISSUE_NUMBER: '${{ github.event.issue.number }}'
          AVAILABLE_LABELS: '${{ steps.get_labels.outputs.available_labels }}'
          SELECTED_LABELS: '${{ env.SELECTED_LABELS }}'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        with:
          github-token: '${{ steps.auth.outputs.token }}'
          script: |-
            const availableLabels = (process.env.AVAILABLE_LABELS || '').split(',')
              .map((label) => label.trim())
              .sort();

            const selectedLabels = (process.env.SELECTED_LABELS || '').split(',')
              .map((label) => label.trim())
              .filter((label) => availableLabels.includes(label))
              .sort();

            const issueNumber = process.env.ISSUE_NUMBER;
            if (selectedLabels && selectedLabels.length > 0) {
              await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: selectedLabels,
              });
              core.info(`Successfully set labels: ${selectedLabels.join(',')}`);
            } else {
              core.info('No valid labels selected.');
            }

  invoke:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'invoke' && needs.dispatch.outputs.invoke_enabled != 'false'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: .github

      - name: Setup authentication
        id: auth
        uses: jhw7500/automation/.github/actions/setup-gemini-auth@v1.1
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'
          fallback-token: '${{ secrets.GITHUB_TOKEN || github.token }}'

      - name: Run Gemini CLI
        uses: google-github-actions/run-gemini-cli@v0
        env:
          TITLE: '${{ github.event.pull_request.title || github.event.issue.title }}'
          DESCRIPTION: '${{ github.event.pull_request.body || github.event.issue.body }}'
          EVENT_NAME: '${{ github.event_name }}'
          GITHUB_TOKEN: '${{ steps.auth.outputs.token }}'
          IS_PULL_REQUEST: '${{ !!github.event.pull_request }}'
          ISSUE_NUMBER: '${{ github.event.pull_request.number || github.event.issue.number }}'
          REPOSITORY: '${{ github.repository }}'
          ADDITIONAL_CONTEXT: '${{ needs.dispatch.outputs.additional_context }}'
        with:
          gcp_location: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          gcp_project_id: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          gcp_service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          gcp_workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          gemini_cli_version: '${{ vars.GEMINI_CLI_VERSION }}'
          gemini_debug: "${{ vars.GEMINI_DEBUG == 'true' || vars.ACTIONS_STEP_DEBUG == 'true' }}"
          gemini_model: '${{ vars.GEMINI_MODEL }}'
          google_api_key: '${{ secrets.GOOGLE_API_KEY }}'
          use_gemini_code_assist: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          use_vertex_ai: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          upload_artifacts: '${{ vars.UPLOAD_ARTIFACTS }}'
          workflow_name: 'gemini-invoke'
          settings: |-
            {
              "model": { "maxSessionTurns": 25 },
              "telemetry": { "enabled": true, "target": "local", "outfile": ".gemini/telemetry.log" },
              "tools": {
                "core": [
                  "run_shell_command(cat)",
                  "run_shell_command(echo)",
                  "run_shell_command(grep)",
                  "run_shell_command(head)",
                  "run_shell_command(tail)"
                ]
              }
            }
          prompt: '/gemini-invoke'

  skipped:
    name: Workflow Skipped
    needs: check-enabled
    if: needs.check-enabled.outputs.enabled != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Notice
        run: |
          echo "::notice::Gemini Dispatch workflow is disabled in .github/workflow-config.yml"
          echo "## Workflow Skipped" >> $GITHUB_STEP_SUMMARY
          echo "Gemini Dispatch is disabled in workflow-config.yml" >> $GITHUB_STEP_SUMMARY
